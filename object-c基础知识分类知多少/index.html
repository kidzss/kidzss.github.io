<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Object C基础知识（分类知多少） - Even - A super concise theme for Hugo</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="kidzss" /><meta name="description" content="1.分类的概念： Category是Objective-C 2.0之后添加的语言特性，Category的主要作用是为已经存在的类添加方法。 Cat" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.61.0 with theme even" />


<link rel="canonical" href="https://kidzss.github.io/object-c%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%88%86%E7%B1%BB%E7%9F%A5%E5%A4%9A%E5%B0%91/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Object C基础知识（分类知多少）" />
<meta property="og:description" content="1.分类的概念： Category是Objective-C 2.0之后添加的语言特性，Category的主要作用是为已经存在的类添加方法。 Cat" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://kidzss.github.io/object-c%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%88%86%E7%B1%BB%E7%9F%A5%E5%A4%9A%E5%B0%91/" />
<meta property="article:published_time" content="2020-02-11T11:33:24+08:00" />
<meta property="article:modified_time" content="2020-02-11T11:33:24+08:00" />
<meta itemprop="name" content="Object C基础知识（分类知多少）">
<meta itemprop="description" content="1.分类的概念： Category是Objective-C 2.0之后添加的语言特性，Category的主要作用是为已经存在的类添加方法。 Cat">
<meta itemprop="datePublished" content="2020-02-11T11:33:24&#43;08:00" />
<meta itemprop="dateModified" content="2020-02-11T11:33:24&#43;08:00" />
<meta itemprop="wordCount" content="12014">



<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Object C基础知识（分类知多少）"/>
<meta name="twitter:description" content="1.分类的概念： Category是Objective-C 2.0之后添加的语言特性，Category的主要作用是为已经存在的类添加方法。 Cat"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Even</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Even</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
  <div class="post-content">
    <h2 id="1">1.分类的概念：</h2>
<p><code>Category</code>是Objective-C 2.0之后添加的<code>语言特性</code>，<code>Category</code>的<code>主要作用</code>是为已经存在的类添加方法。
<code>Category</code>也可以说是OC作为一门<code>动态语言</code>的一<code>大特色</code>。<code>Category</code>为我们<code>动态扩展</code>类的功能提供了可能，或者我们也可以把一个庞大的类进行功能分解，按照<code>category</code>进行组织。</p>
<h2 id="2">2.分类的形式：</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="n">interface</span> <span class="err">宿</span><span class="err">主</span><span class="err">类</span><span class="err">（</span><span class="err">分</span><span class="err">类</span><span class="err">的</span><span class="err">名</span><span class="err">称</span><span class="err">）</span>
<span class="n">end</span>
<span class="n">implementation</span> <span class="err">宿</span><span class="err">主</span><span class="err">类</span><span class="err">（</span><span class="err">分</span><span class="err">类</span><span class="err">的</span><span class="err">名</span><span class="err">称</span><span class="err">）</span>
<span class="n">end</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><code>分类</code>是向<code>原类</code>中增加<code>一组方法</code>和<code>实现</code>，分类是方法不是类，故无需继承父类，但有自己的.h和.m文件</li>
<li>分类只能向<code>原类</code>中增加方法，或者<code>重写</code>原类的方法。分类中定义的方法会成为<code>原类的一部分</code>，和原类中声明的方法<code>没有任何区别</code>。</li>
<li>因为分类不能添加实例变量，而get/set的实现必须使用_实例变量。所以分类中的@property只会生成getter setter方法的声明，不会自动合成_实例变量和get/set方法的实现。</li>
<li>类.h中定义的方法必须实现，但分类.h中定义的方法，可以不实现(如作非正式协议或前向引用时)</li>
<li>重写原类的同名方法，调用时分类的<code>优先级高</code>。如果在类目中<code>覆盖</code>现有类的方法，这样会引起super的消息的断裂，因为类目中的方法具有更高的优先级，因此，一般不要覆盖现有类中的方法。</li>
<li>如果单独创建分类，则分类<code>.h中声明方法</code>属于公开的。</li>
<li>分类如果写在原类.h中，声明的方法是公开的。分类如果写在<code>原类.m中</code>，声明的方法是<code>私有的</code>。</li>
<li>分类向原类中添加的方法也会被子类<code>继承</code></li>
<li>分类和类扩展也可以遵守协议</li>
</ul>
<h2 id="3">3.分类的特点</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">1.运行时决议（跟扩展的一个显著的不同点）
  1.1 在编译阶段并没有把分类添加到宿主类中，宿主类没有对应分类方法
  1.2 在运行时，通过runtime，把分类中添加的内容真实的添加到对应的宿主上
2.可以为系统类添加分类（扩展无法实现）
3.分类添加的方法可以&#34;覆盖&#34;原类方法
4.同名分类方法谁能生效取决于编译顺序
5.名字相同的分类会引起编译报错
6.分类添加的新方法可以被子类继承
</code></pre></td></tr></table>
</div>
</div><h2 id="4category">4.Category源码：</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="k">struct</span> <span class="n">category_t</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span><span class="c1">//分类的名称
</span><span class="c1"></span>    <span class="n">classref_t</span> <span class="n">cls</span><span class="p">;</span><span class="c1">//分类所属的宿主类
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">method_list_t</span> <span class="o">*</span><span class="n">instanceMethods</span><span class="p">;</span> <span class="c1">// 实例方法列表
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">method_list_t</span> <span class="o">*</span><span class="n">classMethods</span><span class="p">;</span> <span class="c1">// 类方法列表
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">protocol_list_t</span> <span class="o">*</span><span class="n">protocols</span><span class="p">;</span> <span class="c1">// 协议列表
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">property_list_t</span> <span class="o">*</span><span class="n">instanceProperties</span><span class="p">;</span> <span class="c1">// 属性列表
</span><span class="c1"></span>    <span class="c1">// Fields below this point are not always present on disk.
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">property_list_t</span> <span class="o">*</span><span class="n">_classProperties</span><span class="p">;</span>

    <span class="n">method_list_t</span> <span class="o">*</span><span class="nf">methodsForMeta</span><span class="p">(</span><span class="kt">bool</span> <span class="n">isMeta</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">isMeta</span><span class="p">)</span> <span class="k">return</span> <span class="n">classMethods</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">return</span> <span class="n">instanceMethods</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">property_list_t</span> <span class="o">*</span><span class="nf">propertiesForMeta</span><span class="p">(</span><span class="kt">bool</span> <span class="n">isMeta</span><span class="p">)</span> <span class="p">{</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">isMeta</span><span class="p">)</span> <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span><span class="c1">//classProperties;
</span><span class="c1"></span>	    <span class="k">else</span> <span class="k">return</span> <span class="n">instanceProperties</span><span class="p">;</span>
    <span class="p">}</span> 
<span class="p">}</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>从源码基本可以看出<code>categroy</code>，<code>对象方法</code>，<code>类方法</code>，<code>协议</code>，<code>属性</code>都可以找到对应的存储方式。并且我们发现分类结构体中是<code>不存在</code> <code>成员变量</code>的，因此分类中是<code>不允许</code>添加成员变量的。分类中添加的<code>属性</code>并不会帮助我们<code>自动生成</code>成员变量，只会生成get set方法的声明，需要我们自己去实现</p>
</blockquote>
<blockquote>
<p><code>name</code>：是指 <code>class_name</code> 而不是 <code>category_name</code>
<code>cls</code>：要扩展的<code>类对象</code>，编译期间是不会定义的，而是在运行时通过<code> *name</code> 对应到对应的<code>类对象</code>。
<code>instanceMethods</code>：category 中所有给类添加的<code>实例方法</code>的列表。
<code>classMethods</code>：category 中所有添加的<code>类方法</code>的列表。
<code>protocols</code>：category 实现的所有<code>协议</code>的列表。
<code>instanceProperties</code>：category 中添加的所有<code>属性</code>。
从 category 的定义也可以看出 category 可以添加实例方法，类方法，甚至可以实现协议，添加属性，无法添加实例变量。</p>
</blockquote>
<h2 id="5category">5.category的加载</h2>
<p>知道了<code>category</code>的数据结构，我们来深入探究一下category是如何在runtime中实现的。</p>
<p>原理很简单：<code>runtime</code>会分别将<code>category</code> 结构体中的<code>instanceMethods</code>, <code>protocols</code>，<code>instanceProperties</code>添加到<code>target class</code>的<code>实例方法列表</code>，<code>协议列表</code>，<code>属性列表</code>中，会将<code>category</code>结构体中的<code>classMethods</code>添加到<code>target class</code>所对应的<code>元类</code>的实例方法列表中。其本质就相当于<code>runtime</code>在运行时期，修改了<code>target class</code>的结构。
经过这一番修改，<code>category</code>中的方法，就变成了<code>target class</code>方法列表中的一部分，其调用方式也就一模一样啦~
现在，就来看一下具体是怎么实现的。在<code>Mach-O</code>文件中，<code>category</code>数据会被存放在<code>__DATA段下的__</code> <code>objc_catlist section</code>中。
当OC被dyld加载起来时，OC进入其入口点函数_objc_init：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="kt">void</span> <span class="nf">_objc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">bool</span> <span class="n">initialized</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">initialized</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="n">initialized</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    
    <span class="c1">// fixme defer initialization until an objc-using image is found?
</span><span class="c1"></span>    <span class="n">environ_init</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
    <span class="n">tls_init</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
    <span class="n">static_init</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
    <span class="n">lock_init</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
    <span class="n">exception_init</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

    <span class="n">_dyld_objc_notify_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map_images</span><span class="p">,</span> <span class="n">load_images</span><span class="p">,</span> <span class="n">unmap_image</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>忽略一堆init方法，重点来看<code>_dyld_objc_notify_register</code>方法。该方法会向<code>dyld</code>注册监听<code>Mach-O</code>中<code>OC</code>相关<code>section</code>被加载入载出内存的事件。</p>
<p>具体有三个事件：
<code>_dyld_objc_notify_mapped</code>(对应&amp;map_images回调)：当dyld已将images加载入内存时。
<code>_dyld_objc_notify_init</code>(对应load_images回调)：当dyld初始化image后。OC调用类的+load方法，就是在这时进行的。
<code>_dyld_objc_notify_unmapped</code>(对应unmap_image回调)：当dyld将images移除内存时。
而<code>category</code>写入<code>target class</code>的方法列表，则是在<code>_dyld_objc_notify_mapped</code>，即将<code>Mach-O</code>相关<code>sections</code>都加载到内存之后所发生的。
我们可以看到其对应回调为map_images方法。</p>
<p>在<code>map_images</code> 最终会调用<code>_read_images</code> 方法来读取<code>OC</code>相关<code>sections</code>，并以此来初始化<code>OC</code>内存环境。<code>_read_images</code> 的极简实现版如下，可以看到，rumtime是如何根据Mach-O各个section的信息来初始化其自身的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="kt">void</span> <span class="nf">_read_images</span><span class="p">(</span><span class="n">header_info</span> <span class="o">*</span><span class="o">*</span><span class="n">hList</span><span class="p">,</span> <span class="n">uint32_t</span> <span class="n">hCount</span><span class="p">,</span> <span class="kt">int</span> <span class="n">totalClasses</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unoptimizedTotalClasses</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">bool</span> <span class="n">doneOnce</span><span class="p">;</span>
    <span class="n">TimeLogger</span> <span class="n">ts</span><span class="p">(</span><span class="n">PrintImageTimes</span><span class="p">)</span><span class="p">;</span>
    <span class="n">runtimeLock</span><span class="p">.</span><span class="n">assertWriting</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">doneOnce</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">doneOnce</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
        <span class="n">ts</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">IMAGE TIMES: first time tasks</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// Discover classes. Fix up unresolved future classes. Mark bundle classes.
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">EACH_HEADER</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">classref_t</span> <span class="o">*</span><span class="n">classlist</span> <span class="o">=</span> <span class="n">_getObjc2ClassList</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">)</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="p">(</span><span class="kt">Class</span><span class="p">)</span><span class="n">classlist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
            <span class="kt">Class</span> <span class="n">newCls</span> <span class="o">=</span> <span class="n">readClass</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">headerIsBundle</span><span class="p">,</span> <span class="n">headerIsPreoptimized</span><span class="p">)</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="n">ts</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">IMAGE TIMES: discover classes</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>
    
    <span class="c1">// Fix up remapped classes
</span><span class="c1"></span>    <span class="c1">// Class list and nonlazy class list remain unremapped.
</span><span class="c1"></span>    <span class="c1">// Class refs and super refs are remapped for message dispatching.
</span><span class="c1"></span>
    <span class="k">for</span> <span class="p">(</span><span class="n">EACH_HEADER</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">Class</span> <span class="o">*</span><span class="n">classrefs</span> <span class="o">=</span> <span class="n">_getObjc2ClassRefs</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">)</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">remapClassRef</span><span class="p">(</span><span class="o">&amp;</span><span class="n">classrefs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">)</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// fixme why doesn&#39;t test future1 catch the absence of this?
</span><span class="c1"></span>        <span class="n">classrefs</span> <span class="o">=</span> <span class="n">_getObjc2SuperRefs</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">)</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">remapClassRef</span><span class="p">(</span><span class="o">&amp;</span><span class="n">classrefs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">)</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
   
    <span class="n">ts</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">IMAGE TIMES: remap classes</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="n">EACH_HEADER</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">hi</span><span class="o">-</span><span class="o">&gt;</span><span class="n">isPreoptimized</span><span class="p">(</span><span class="p">)</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">isBundle</span> <span class="o">=</span> <span class="n">hi</span><span class="o">-</span><span class="o">&gt;</span><span class="n">isBundle</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
        <span class="kt">SEL</span> <span class="o">*</span><span class="n">sels</span> <span class="o">=</span> <span class="n">_getObjc2SelectorRefs</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">)</span><span class="p">;</span>
        <span class="n">UnfixedSelectors</span> <span class="o">+</span><span class="o">=</span> <span class="n">count</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">sel_cname</span><span class="p">(</span><span class="n">sels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">)</span><span class="p">;</span>
            <span class="n">sels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sel_registerNameNoLock</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">isBundle</span><span class="p">)</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="n">ts</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">IMAGE TIMES: fix up selector references</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>
    
    <span class="c1">// Discover protocols. Fix up protocol refs.
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">EACH_HEADER</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">extern</span> <span class="n">objc_class</span> <span class="n">OBJC_CLASS_</span><span class="err">$</span><span class="n">_Protocol</span><span class="p">;</span>
        <span class="kt">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="p">(</span><span class="kt">Class</span><span class="p">)</span><span class="o">&amp;</span><span class="n">OBJC_CLASS_</span><span class="err">$</span><span class="n">_Protocol</span><span class="p">;</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span><span class="p">;</span>
        <span class="n">NXMapTable</span> <span class="o">*</span><span class="n">protocol_map</span> <span class="o">=</span> <span class="n">protocols</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">isPreoptimized</span> <span class="o">=</span> <span class="n">hi</span><span class="o">-</span><span class="o">&gt;</span><span class="n">isPreoptimized</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">isBundle</span> <span class="o">=</span> <span class="n">hi</span><span class="o">-</span><span class="o">&gt;</span><span class="n">isBundle</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
        
        <span class="n">protocol_t</span> <span class="o">*</span><span class="o">*</span><span class="n">protolist</span> <span class="o">=</span> <span class="n">_getObjc2ProtocolList</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">)</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">readProtocol</span><span class="p">(</span><span class="n">protolist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">,</span> <span class="n">cls</span><span class="p">,</span> <span class="n">protocol_map</span><span class="p">,</span>
                         <span class="n">isPreoptimized</span><span class="p">,</span> <span class="n">isBundle</span><span class="p">)</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="n">ts</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">IMAGE TIMES: discover protocols</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>
    
    <span class="c1">// Fix up @protocol references
</span><span class="c1"></span>    <span class="c1">// Preoptimized images may have the right
</span><span class="c1"></span>    <span class="c1">// answer already but we don&#39;t know for sure.
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">EACH_HEADER</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">protocol_t</span> <span class="o">*</span><span class="o">*</span><span class="n">protolist</span> <span class="o">=</span> <span class="n">_getObjc2ProtocolRefs</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">)</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">remapProtocolRef</span><span class="p">(</span><span class="o">&amp;</span><span class="n">protolist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">)</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="n">ts</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">IMAGE TIMES: fix up @protocol references</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>
    
    <span class="c1">// Realize non-lazy classes (for +load methods and static instances)
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">EACH_HEADER</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">classref_t</span> <span class="o">*</span><span class="n">classlist</span> <span class="o">=</span>
        <span class="n">_getObjc2NonlazyClassList</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">)</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="n">remapClass</span><span class="p">(</span><span class="n">classlist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">)</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cls</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
            <span class="n">realizeClass</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="n">ts</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">IMAGE TIMES: realize non-lazy classes</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>
    <span class="c1">// Realize newly-resolved future classes, in case CF manipulates them
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">resolvedFutureClasses</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">resolvedFutureClassCount</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">realizeClass</span><span class="p">(</span><span class="n">resolvedFutureClasses</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">)</span><span class="p">;</span>
            <span class="n">resolvedFutureClasses</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="o">&gt;</span><span class="n">setInstancesRequireRawIsa</span><span class="p">(</span><span class="nb">false</span><span class="cm">/*inherited*/</span><span class="p">)</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">free</span><span class="p">(</span><span class="n">resolvedFutureClasses</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ts</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">IMAGE TIMES: realize future classes</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>
    
    <span class="c1">// Discover categories.
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">EACH_HEADER</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">category_t</span> <span class="o">*</span><span class="o">*</span><span class="n">catlist</span> <span class="o">=</span>
        <span class="n">_getObjc2CategoryList</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">)</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">hasClassProperties</span> <span class="o">=</span> <span class="n">hi</span><span class="o">-</span><span class="o">&gt;</span><span class="n">info</span><span class="p">(</span><span class="p">)</span><span class="o">-</span><span class="o">&gt;</span><span class="n">hasCategoryClassProperties</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
        
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">category_t</span> <span class="o">*</span><span class="n">cat</span> <span class="o">=</span> <span class="n">catlist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
            <span class="kt">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="n">remapClass</span><span class="p">(</span><span class="n">cat</span><span class="o">-</span><span class="o">&gt;</span><span class="n">cls</span><span class="p">)</span><span class="p">;</span>
            <span class="kt">bool</span> <span class="n">classExists</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cat</span><span class="o">-</span><span class="o">&gt;</span><span class="n">instanceMethods</span> <span class="o">|</span><span class="o">|</span>  <span class="n">cat</span><span class="o">-</span><span class="o">&gt;</span><span class="n">protocols</span>
                <span class="o">|</span><span class="o">|</span>  <span class="n">cat</span><span class="o">-</span><span class="o">&gt;</span><span class="n">instanceProperties</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">addUnattachedCategoryForClass</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="n">cls</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span><span class="p">;</span>
            <span class="p">}</span>
            
            <span class="k">if</span> <span class="p">(</span><span class="n">cat</span><span class="o">-</span><span class="o">&gt;</span><span class="n">classMethods</span>  <span class="o">|</span><span class="o">|</span>  <span class="n">cat</span><span class="o">-</span><span class="o">&gt;</span><span class="n">protocols</span>
                <span class="o">|</span><span class="o">|</span>  <span class="p">(</span><span class="n">hasClassProperties</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="n">cat</span><span class="o">-</span><span class="o">&gt;</span><span class="n">_classProperties</span><span class="p">)</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">addUnattachedCategoryForClass</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="n">cls</span><span class="o">-</span><span class="o">&gt;</span><span class="n">ISA</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="n">ts</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">IMAGE TIMES: discover categories</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>discover categories的逻辑如下</code>：</p>
<ul>
<li>先调用<code>_getObjc2CategoryList</code>读取<code>__objc_catlist</code> <code>seciton</code>下所记录的所有<code>category</code>。并存放到<code>category_t *</code>数组中。(<code>找到所以的category</code>)</li>
<li>依次读取数组中的category_t * cat</li>
<li>对每一个<code>cat</code>，先调用<code>remapClass(cat-&gt;cls)</code>，并返回一个<code>objc_class*对象cls</code>。这一步的目的在于找到到category对应的类对象cls。(<code>读取每个category，并找到对应的class</code>)</li>
<li>找到category对应的类对象cls后，就开始进行对cls的修改操作了。首先，如果category中有实例方法，协议，和实例属性之一的话，则直接对cls进行操作。如果category中包含了类方法，协议，类属性（不支持）之一的话，还要对cls所对应的元类(cls-&gt;ISA())进行操作。</li>
<li>不管是对<code>cls</code>还是<code>cls的元类</code>进行操作，都是调用的方法<code>addUnattachedCategoryForClass</code>。但这个方法并不是category实现的关键，其内部逻辑只是将<code>class</code>和其对应的<code>category</code>做了一个<code>映射</code>。这样，以<code>class</code>为<code>key</code>，就可以取到所其对应的所有的<code>category</code>。(<code>每个category跟 class或者class的元类做映射</code>)</li>
<li>做好<code>class</code>和<code>category</code>的映射后，会调用<code>remethodizeClass</code>方法来修改<code>class</code>的<code>method list</code>结构，这才是runtime实现category的关键所在。(<code>调用remethodizeClass 修改class的method list</code>)</li>
</ul>
<h3 id="-getobjc2classlist">_getObjc2ClassList</h3>
<p><code>_getObjc2ClassList</code> 方法获取所有的 Category 然后添加到 catlist 数组中；把 Category 的实例方法、协议以及属性添加到类上；把 Category 的类方法和协议添加到类的 metaclass 上。addUnattachedCategoryForClass 方法只是把类和 Category 做一个关联映射。</p>
<h3 id="remethodizeclass">remethodizeClass</h3>
<p><code>remethodizeClass</code>是<code>category</code>的实现核心，细看一下该方法的实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="cm">/***********************************************************************
</span><span class="cm">* remethodizeClass
</span><span class="cm">* Attach outstanding categories to an existing class.
</span><span class="cm">* Fixes up cls&#39;s method list, protocol list, and property list.
</span><span class="cm">* Updates method caches for cls and its subclasses.
</span><span class="cm">* Locking: runtimeLock must be held by the caller
</span><span class="cm">**********************************************************************/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">remethodizeClass</span><span class="p">(</span><span class="kt">Class</span> <span class="n">cls</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">category_list</span> <span class="o">*</span><span class="n">cats</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">isMeta</span><span class="p">;</span>

    <span class="n">runtimeLock</span><span class="p">.</span><span class="n">assertWriting</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
    <span class="n">isMeta</span> <span class="o">=</span> <span class="n">cls</span><span class="o">-</span><span class="o">&gt;</span><span class="n">isMetaClass</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

    <span class="c1">// Re-methodizing: check for more categories
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="p">(</span><span class="n">cats</span> <span class="o">=</span> <span class="n">unattachedCategoriesForClass</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="nb">false</span><span class="cm">/*not realizing*/</span><span class="p">)</span><span class="p">)</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">PrintConnecting</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">_objc_inform</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">CLASS: attaching categories to class &#39;%s&#39; %s</span><span class="s">&#34;</span><span class="p">,</span> 
                         <span class="n">cls</span><span class="o">-</span><span class="o">&gt;</span><span class="n">nameForLogging</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">isMeta</span> <span class="o">?</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">(meta)</span><span class="s">&#34;</span> <span class="o">:</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="n">attachCategories</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">cats</span><span class="p">,</span> <span class="nb">true</span> <span class="cm">/*flush caches*/</span><span class="p">)</span><span class="p">;</span>        
        <span class="n">free</span><span class="p">(</span><span class="n">cats</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>该段代码首先通过<code>unattachedCategoriesForClass</code> 取出还未被附加到<code>class</code>上的<code>category list</code>，然后调用<code>attachCategories</code>将这些<code>category</code>附加到<code>class</code>上。
remethodizeClass 方法将  Category 合并到类中，然后更新类的方法列表、协议列表和属性列表，更新类以及子类的方法缓存。</p>
<p>通过上述代码我们发现attachCategories函数接收了类对象cls和分类数组cats，如我们一开始写的代码所示，一个类可以有多个分类。之前我们说到分类信息存储在category_t结构体中，那么多个分类则保存在category_list中</p>
<h3 id="attachcategories">attachCategories</h3>
<p><code>attachCategories</code> 的实现如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// Attach method lists and properties and protocols from categories to a class.
</span><span class="c1"></span><span class="c1">// Assumes the categories in cats are all loaded and sorted by load order, 
</span><span class="c1"></span><span class="c1">// oldest categories first.
</span><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> 
<span class="nf">attachCategories</span><span class="p">(</span><span class="kt">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="n">category_list</span> <span class="o">*</span><span class="n">cats</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">flush_caches</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cats</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PrintReplacedMethods</span><span class="p">)</span> <span class="n">printReplacements</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">cats</span><span class="p">)</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="n">isMeta</span> <span class="o">=</span> <span class="n">cls</span><span class="o">-</span><span class="o">&gt;</span><span class="n">isMetaClass</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

    <span class="c1">// 首先分配method_list_t *， property_list_t *， protocol_list_t *的数组空间，数组大小等于category的个数
</span><span class="c1"></span>    <span class="n">method_list_t</span> <span class="o">*</span><span class="o">*</span><span class="n">mlists</span> <span class="o">=</span> <span class="p">(</span><span class="n">method_list_t</span> <span class="o">*</span><span class="o">*</span><span class="p">)</span>
        <span class="n">malloc</span><span class="p">(</span><span class="n">cats</span><span class="o">-</span><span class="o">&gt;</span><span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mlists</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
    <span class="n">property_list_t</span> <span class="o">*</span><span class="o">*</span><span class="n">proplists</span> <span class="o">=</span> <span class="p">(</span><span class="n">property_list_t</span> <span class="o">*</span><span class="o">*</span><span class="p">)</span>
        <span class="n">malloc</span><span class="p">(</span><span class="n">cats</span><span class="o">-</span><span class="o">&gt;</span><span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">proplists</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
    <span class="n">protocol_list_t</span> <span class="o">*</span><span class="o">*</span><span class="n">protolists</span> <span class="o">=</span> <span class="p">(</span><span class="n">protocol_list_t</span> <span class="o">*</span><span class="o">*</span><span class="p">)</span>
        <span class="n">malloc</span><span class="p">(</span><span class="n">cats</span><span class="o">-</span><span class="o">&gt;</span><span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">protolists</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>

    <span class="c1">// Count backwards through cats to get newest categories first
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">mcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">propcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">protocount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">cats</span><span class="o">-</span><span class="o">&gt;</span><span class="n">count</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">fromBundle</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="o">-</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 依次读取每一个category，将其methods，property，protocol添加到mlists，proplist，protolist中存储
</span><span class="c1"></span>        <span class="k">auto</span><span class="o">&amp;</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">cats</span><span class="o">-</span><span class="o">&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>

        <span class="n">method_list_t</span> <span class="o">*</span><span class="n">mlist</span> <span class="o">=</span> <span class="n">entry</span><span class="p">.</span><span class="n">cat</span><span class="o">-</span><span class="o">&gt;</span><span class="n">methodsForMeta</span><span class="p">(</span><span class="n">isMeta</span><span class="p">)</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mlist</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">mlists</span><span class="p">[</span><span class="n">mcount</span><span class="o">+</span><span class="o">+</span><span class="p">]</span> <span class="o">=</span> <span class="n">mlist</span><span class="p">;</span>
            <span class="n">fromBundle</span> <span class="o">|</span><span class="o">=</span> <span class="n">entry</span><span class="p">.</span><span class="n">hi</span><span class="o">-</span><span class="o">&gt;</span><span class="n">isBundle</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">property_list_t</span> <span class="o">*</span><span class="n">proplist</span> <span class="o">=</span> 
            <span class="n">entry</span><span class="p">.</span><span class="n">cat</span><span class="o">-</span><span class="o">&gt;</span><span class="n">propertiesForMeta</span><span class="p">(</span><span class="n">isMeta</span><span class="p">,</span> <span class="n">entry</span><span class="p">.</span><span class="n">hi</span><span class="p">)</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">proplist</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">proplists</span><span class="p">[</span><span class="n">propcount</span><span class="o">+</span><span class="o">+</span><span class="p">]</span> <span class="o">=</span> <span class="n">proplist</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">protocol_list_t</span> <span class="o">*</span><span class="n">protolist</span> <span class="o">=</span> <span class="n">entry</span><span class="p">.</span><span class="n">cat</span><span class="o">-</span><span class="o">&gt;</span><span class="n">protocols</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">protolist</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">protolists</span><span class="p">[</span><span class="n">protocount</span><span class="o">+</span><span class="o">+</span><span class="p">]</span> <span class="o">=</span> <span class="n">protolist</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

	<span class="c1">// 取出class的data()数据，其实是class_rw_t * 指针，其对应结构体实例存储了class的基本信息
</span><span class="c1"></span>    <span class="k">auto</span> <span class="n">rw</span> <span class="o">=</span> <span class="n">cls</span><span class="o">-</span><span class="o">&gt;</span><span class="n">data</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

    <span class="n">prepareMethodLists</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">mlists</span><span class="p">,</span> <span class="n">mcount</span><span class="p">,</span> <span class="nb">NO</span><span class="p">,</span> <span class="n">fromBundle</span><span class="p">)</span><span class="p">;</span>
    <span class="n">rw</span><span class="o">-</span><span class="o">&gt;</span><span class="n">methods</span><span class="p">.</span><span class="n">attachLists</span><span class="p">(</span><span class="n">mlists</span><span class="p">,</span> <span class="n">mcount</span><span class="p">)</span><span class="p">;</span>  <span class="c1">// 将category中的method 添加到class中
</span><span class="c1"></span>    <span class="n">free</span><span class="p">(</span><span class="n">mlists</span><span class="p">)</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">flush_caches</span>  <span class="o">&amp;</span><span class="o">&amp;</span>  <span class="n">mcount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">flushCaches</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span><span class="p">;</span> <span class="c1">// 如果需要，同时刷新class的method list cache
</span><span class="c1"></span>
    <span class="n">rw</span><span class="o">-</span><span class="o">&gt;</span><span class="n">properties</span><span class="p">.</span><span class="n">attachLists</span><span class="p">(</span><span class="n">proplists</span><span class="p">,</span> <span class="n">propcount</span><span class="p">)</span><span class="p">;</span> <span class="c1">// 将category的property添加到class中
</span><span class="c1"></span>    <span class="n">free</span><span class="p">(</span><span class="n">proplists</span><span class="p">)</span><span class="p">;</span>

    <span class="n">rw</span><span class="o">-</span><span class="o">&gt;</span><span class="n">protocols</span><span class="p">.</span><span class="n">attachLists</span><span class="p">(</span><span class="n">protolists</span><span class="p">,</span> <span class="n">protocount</span><span class="p">)</span><span class="p">;</span> <span class="c1">// 将category的protocol添加到class中
</span><span class="c1"></span>    <span class="n">free</span><span class="p">(</span><span class="n">protolists</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述源码中可以看出:</p>
<ul>
<li>
<p>根据<code>方法列表</code>，<code>属性列表</code>，<code>协议列表</code>，malloc分配内存，根据多少个分类以及每一块方法需要多少内存来分配相应的内存地址。</p>
</li>
<li>
<p>从<code>分类数组</code>里面往三个数组里面<code>存放</code>分类数组里面存放的分类方法，属性以及协议放入对应<code>mlist</code>、<code>proplists</code>、<code>protolosts</code>数组中，这三个数组放着所有分类的方法，属性和协议。</p>
</li>
<li>
<p>通过<code>类对象</code>的<code>data()</code>方法，拿到类对象的<code>class_rw_t结构体rw</code>，class_rw_t中存放着<code>类对象</code>的<code>方法</code>，<code>属性</code>和<code>协议</code>等数据，rw结构体通过类对象的data方法获取，所以rw里面存放这类对象里面的数据。</p>
</li>
<li>
<p>分别通过rw调用<code>方法列表</code>、<code>属性列表</code>、协<code>议列表</code>的<code>attachList</code>函数，将所有的<code>分类</code>的<code>方法</code>、<code>属性</code>、<code>协议列表</code>数组传进去，<code>在attachList</code>方法内部将分类和本类相应的对象方法，属性，和协议进行了<code>合并</code>。</p>
</li>
</ul>
<p>到此为止，我们就完成了<code>category</code>的加载工作。可以看到，最终，<code>cateogry</code>被加入到了对应<code>class</code>的方法，协议以及属性列表中。</p>
<p>attachCategories 方法中，将方法列表、属性和协议列表从 Category 合并到类中。
首先根据方法列表，属性列表，协议列表，malloc 分配内存，根据多少个分类以及每一块方法需要多少内存来分配相应的内存地址。
通过 while 循环，遍历所有的 Category，得到它的方法列表 mlist 、proplist 和 protolist 并存入 mlists 、proplists 和 protolists 中。换句话说，它的主要作用就是将 Category 中的方法、属性和协议拼接到类（主类或元类）中，更新类的数据字段 data() 中 mlist、proplist 和 protolist 的值。
之后通过类对象的 data() 方法，调用方法列表、属性列表、协议列表的 attachList 函数，将所有的分类的方法、属性、协议列表数组传进去，将分类和本类相应的对象方法，属性，和协议进行了合并。</p>
<h3 id="attachlists">attachLists</h3>
<p>最后我们再看一下<code>attachLists</code>方法是如何将<code>两个list</code>合二为一的：
<code>array()-&gt;lists</code>： 类对象原来的方法列表，属性列表，协议列表。
<code>addedLists</code>：传入所有分类的方法列表，属性列表，协议列表。
<img src="./1543720827707.png" alt="Alt text">
仔细看会发现，<code>attachLists</code>方法其实是使用的<code>头插</code>的方式将新的<code>list</code>插入原有<code>list</code>中的。即，新的<code>list</code>会插入到原始<code>list</code>的头部。</p>
<p>这也就说明了，为什么<code>category</code>中的方法，会<code>‘覆盖’</code> <code>class</code>的原始方法。其实并没有真正的<code>‘覆盖’</code>，而是由于<code>cateogry</code>中的方法被排到了原始方法的前面，那么在消息查找流程中，会返回首先被查找到的cateogry方法的实现。</p>
<h3 id="memmove--memcpy">memmove &amp; memcpy</h3>
<p>attachLists函数中最重要的两个方法为memmove内存移动和memcpy内存拷贝。我们先来分别看一下这两个函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// memmove ：内存移动。
</span><span class="c1"></span><span class="cm">/*  __dst : 移动内存的目的地
</span><span class="cm">*   __src : 被移动的内存首地址
</span><span class="cm">*   __len : 被移动的内存长度
</span><span class="cm">*   将__src的内存移动__len块内存到__dst中
</span><span class="cm">*/</span>
<span class="kt">void</span>    <span class="o">*</span><span class="nf">memmove</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">__dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">__src</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">__len</span><span class="p">)</span><span class="p">;</span>

<span class="c1">// memcpy ：内存拷贝。
</span><span class="c1"></span><span class="cm">/*  __dst : 拷贝内存的拷贝目的地
</span><span class="cm">*   __src : 被拷贝的内存首地址
</span><span class="cm">*   __n : 被移动的内存长度
</span><span class="cm">*   将__src的内存移动__n块内存到__dst中
</span><span class="cm">*/</span>
<span class="kt">void</span>    <span class="o">*</span><span class="nf">memcpy</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">__dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">__src</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">__n</span><span class="p">)</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>经过 memmove 和 memcpy 方法之后，分类的方法，属性，协议列表被放在了类对象中原本存储的方法，属性，协议列表前面。为了保证分类方法优先调用，我们知道当分类重写本类的方法时，会覆盖本类的方法。其实经过上面的分析我们知道本质上并不是覆盖，而是优先调用，本类的方法依然在内存中的。
通过以上可以看出：</p>
<p>Category 的方法没有“完全替换掉”原来类已经有的方法，也就是说如果 Category 和原来类都有 methodA，那么 category 附加完成之后，类的方法列表里会有两个 methodA。</p>
<p>Category 的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的 Category 的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休，殊不知后面可能还有一样名字的方法。</p>
<h3 id="heading">分类加载流程</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">//通过上面的源码我们发现，分类的方法，协议，属性等确实是存放在Categroy结构体里面的，下面简单说明加载过程
</span><span class="c1"></span><span class="mf">1.</span><span class="n">_objc_init</span><span class="p">(</span><span class="n">runtime</span> <span class="err">初</span><span class="err">始</span><span class="err">化</span><span class="p">)</span>
  <span class="mf">2.</span><span class="n">map_2_images</span><span class="err">（</span><span class="n">images</span><span class="err">：</span><span class="err">镜</span><span class="err">像</span><span class="err">）</span>
    <span class="mf">3.</span><span class="n">map_images_nolock</span>
      <span class="mf">4.</span><span class="n">_read_images</span><span class="err">（</span><span class="err">加</span><span class="err">载</span><span class="err">可</span><span class="err">执</span><span class="err">行</span><span class="err">文</span><span class="err">件</span><span class="err">到</span><span class="err">内</span><span class="err">存</span><span class="err">中</span><span class="err">）</span>
        <span class="mf">5.</span><span class="n">remethodizeClass</span><span class="p">(</span><span class="err">分</span><span class="err">类</span><span class="err">的</span><span class="err">加</span><span class="err">载</span><span class="err">的</span><span class="err">开</span><span class="err">始</span> <span class="p">)</span>
          <span class="mf">5.1</span> <span class="err">获</span><span class="err">取</span><span class="n">cls中的所有分类列表</span><span class="p">(</span><span class="n">cats</span><span class="p">)</span> 
          <span class="mf">5.2</span> <span class="err">将</span><span class="err">分</span><span class="err">类</span><span class="n">cats拼接到cls上</span>
          <span class="mf">5.3</span> <span class="n">method_list_t</span><span class="p">,</span><span class="n">property_list_t</span><span class="p">,</span><span class="n">protocol_list_t</span>
          <span class="c1">//每个list就是一个二维数组，类似这样的结构：[[method_t,...],[method_t],[method_t,...]]
</span><span class="c1"></span>          <span class="c1">//内部每个小的数组就是一个分类，每个method_t就是一个分类的中方法
</span><span class="c1"></span>          <span class="c1">//获取宿主类中分类的总数cats-&gt;count
</span><span class="c1"></span>          <span class="nl">i</span> <span class="p">:</span><span class="o">=</span> <span class="n">cats</span><span class="o">-</span><span class="o">&gt;</span><span class="n">count</span>
          <span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="o">-</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">//cats中最后一个元素是最后参加编译的
</span><span class="c1"></span>            <span class="c1">//倒序遍历，最先访问最后编译的分类
</span><span class="c1"></span>            <span class="c1">//如果两个分类有同名的方法，那个方法会最终生效，取决于那个分类最后被编译
</span><span class="c1"></span>            <span class="c1">//最后编译的分类最先添加到分类的数组中，最后编译的分类方法会最终生效
</span><span class="c1"></span>            <span class="c1">//获取宿主类中的方法列表,把mcount个方法的mlists二维数组列表添加到method_list总（分类是运行时决议）
</span><span class="c1"></span>            <span class="n">rw</span><span class="o">-</span><span class="o">&gt;</span><span class="n">method</span><span class="p">.</span><span class="n">attachList</span><span class="p">(</span><span class="n">mlists</span><span class="p">,</span><span class="n">mcount</span><span class="p">)</span>
            <span class="c1">//attachList实现
</span><span class="c1"></span>            <span class="mf">1.</span><span class="err">获</span><span class="err">取</span><span class="err">列</span><span class="err">表</span><span class="err">中</span><span class="err">原</span><span class="err">有</span><span class="err">元</span><span class="err">素</span><span class="err">的</span><span class="err">总</span><span class="err">数</span> <span class="n">oldCount</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="mf">2.</span><span class="err">计</span><span class="err">算</span><span class="err">拼</span><span class="err">接</span><span class="err">之</span><span class="err">后</span><span class="err">的</span><span class="err">总</span><span class="err">数</span> <span class="n">newCount</span> <span class="o">=</span> <span class="mi">5</span>
            <span class="mf">3.</span><span class="err">根</span><span class="err">据</span><span class="err">总</span><span class="err">数</span><span class="err">重</span><span class="err">新</span><span class="err">分</span><span class="err">配</span><span class="err">内</span><span class="err">存</span>
            <span class="mf">4.</span><span class="err">重</span><span class="err">新</span><span class="err">设</span><span class="err">置</span><span class="err">元</span><span class="err">素</span><span class="err">总</span><span class="err">数</span>
            <span class="mf">5.</span><span class="err">内</span><span class="err">存</span><span class="err">移</span><span class="err">动</span><span class="o">:</span><span class="p">[</span><span class="p">[</span><span class="p">]</span><span class="p">,</span><span class="p">[</span><span class="p">]</span><span class="p">,</span><span class="p">[</span><span class="p">]</span><span class="p">,</span><span class="p">[</span><span class="n">origin1</span><span class="p">]</span><span class="p">,</span><span class="p">[</span><span class="n">origin2</span><span class="p">]</span><span class="p">]</span>
            <span class="mf">6.</span><span class="err">内</span><span class="err">容</span><span class="k">copy</span><span class="o">:</span>
            <span class="p">[</span>
              <span class="n">A</span><span class="o">-</span><span class="o">-</span><span class="o">-</span><span class="o">&gt;</span><span class="p">[</span><span class="n">addedLists中的第一个元素</span><span class="p">]</span>
              <span class="n">B</span><span class="o">-</span><span class="o">-</span><span class="o">-</span><span class="o">&gt;</span><span class="p">[</span><span class="n">addedLists中的第二个元素</span><span class="p">]</span>
              <span class="n">C</span><span class="o">-</span><span class="o">-</span><span class="o">-</span><span class="o">&gt;</span><span class="p">[</span><span class="n">addedLists中的第二个元素</span><span class="p">]</span>
              <span class="p">[</span><span class="n">origin1</span><span class="p">]</span>
              <span class="p">[</span><span class="n">origin2</span><span class="p">]</span>
            <span class="p">]</span>
            <span class="c1">//这个就是分类方法会&#34;覆盖&#34;宿主类方法的原因，宿主类方法实际上仍然存在，但是在消息方法查找，是根据选择器名称来查找的，一旦查找到对应的实现方法就会返回，如果分类中有跟宿主类同名的方法，分类的方法会被优先实现
</span><span class="c1"></span>          <span class="p">}</span>
          <span class="c1">//分类中的对象方法依然是存储在类对象中的，同本类对象方法在同一个地方，调用步骤也同调用对象方法一样。如果是类方法的话，也同样是存储在元类对象中
</span></code></pre></td></tr></table>
</div>
</div><h2 id="categoryload">category和+load方法</h2>
<p><code>在类的+load方法中，可以调用分类方法吗？</code>
要回答这个问题，其实要搞清<code>load</code>方法的调用时机和<code>category</code>附加到<code>class</code>上的先后顺序。
我们回到runtime的入口函数来看一下，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="kt">void</span> <span class="nf">_objc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="kt">bool</span> <span class="n">initialized</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">initialized</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="n">initialized</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    
    <span class="c1">// fixme defer initialization until an objc-using image is found?
</span><span class="c1"></span>    <span class="n">environ_init</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
    <span class="n">tls_init</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
    <span class="n">static_init</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
    <span class="n">lock_init</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
    <span class="n">exception_init</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

    <span class="n">_dyld_objc_notify_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map_images</span><span class="p">,</span> <span class="n">load_images</span><span class="p">,</span> <span class="n">unmap_image</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>runtime</code>在入口点分别向<code>dyld</code>注册了三个事件监听：<code>mapped oc sections</code>， <code>init oc section</code> 以及 <code>unmapped oc sections</code>。
而这三个事件的顺序是: <code>mapped oc sections</code> -&gt; <code>init oc section</code> -&gt; <code>unmapped oc sections</code></p>
<p>在<code>mapped oc sections</code> 事件中，我们已经看过其源码，<code>runtime</code>会依次读取<code>Mach-O</code>文件中的<code>oc sections</code>，并根据这些信息来初始化<code>runtime</code>环境。这其中就包括<code>cateogry</code>的加载。
之后，当<code>runtime</code>环境都初始化完毕，在<code>dyld</code>的<code>init oc section</code> 事件中，<code>runtime</code>会调用每一个加载到内存中的类的+load方法。
这里我们注意到，<code>+load</code>方法的调用是在<code>cateogry</code>加载之后的。因此，在<code>+load</code>方法中，是可以调用<code>category</code>方法的。</p>
<h2 id="category">调用已被category‘覆盖’的方法</h2>
<p>前面我们已经知道，类中的方法并不是真正的被<code>category</code> <code>‘覆盖’</code>，而是被放到了类方法列表的后面，消息查找时找不到而已。我们当然也可以手动来找到并调用它，
1.通过(class_copyMethodList)获取实例方法或者类方法的全部方法
2.通过(NSStringFromSelector)获取需要查找的方法的方法名
3.倒叙遍历所有的方法MethodList，找到第一个方法名相等等的方法
4.获取该方法的imp(method_getImplementation)
5.直接方法调用该imp</p>
<p>代码如下：
<code>Method *class_copyMethodList(Class cls, unsigned int *outCount) 说明：该函数的作用是获取一个类的所有实例方法,如果传入的是类就是获取实例方法，如果通过object_getClass获取到元类，就是元类方法</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="n">interface</span> <span class="nl">Son</span> <span class="p">:</span> <span class="n">NSObject</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">sayHi</span><span class="p">;</span>
<span class="n">end</span>

<span class="n">implementation</span> <span class="n">Son</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">sayHi</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;</span><span class="s">Son say hi!</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">end</span>

<span class="c1">// son 的分类，覆写了sayHi方法
</span><span class="c1"></span><span class="k">@interface</span> <span class="nc">Son</span> <span class="nl">(Good)</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">sayHi</span><span class="p">;</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">saySonHi</span><span class="p">;</span>
<span class="k">@end</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">sayHi</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;</span><span class="s">Son&#39;s category good say hi</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">saySonHi</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">methodCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Method</span> <span class="o">*</span><span class="n">methodList</span> <span class="o">=</span> <span class="n">class_copyMethodList</span><span class="p">(</span><span class="p">[</span><span class="nb">self</span> <span class="k">class</span><span class="p">]</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">methodCount</span><span class="p">)</span><span class="p">;</span>
    
    <span class="kt">SEL</span> <span class="n">sel</span> <span class="o">=</span> <span class="k">@selector</span><span class="p">(</span><span class="n">sayHi</span><span class="p">)</span><span class="p">;</span>
    <span class="n">NSString</span> <span class="o">*</span><span class="n">originalSelName</span> <span class="o">=</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span><span class="p">;</span>
    <span class="kt">IMP</span> <span class="n">lastIMP</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">NSInteger</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">methodCount</span><span class="p">;</span> <span class="o">+</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Method</span> <span class="n">method</span> <span class="o">=</span> <span class="n">methodList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
        <span class="n">NSString</span> <span class="o">*</span><span class="n">selName</span> <span class="o">=</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">method_getName</span><span class="p">(</span><span class="n">method</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="p">[</span><span class="n">originalSelName</span> <span class="nl">isEqualToString</span><span class="p">:</span><span class="n">selName</span><span class="p">]</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">lastIMP</span> <span class="o">=</span> <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">method</span><span class="p">)</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">lastIMP</span> <span class="o">!</span><span class="o">=</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">typedef</span> <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)</span><span class="p">(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">)</span><span class="p">;</span>
        <span class="n">fn</span> <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">fn</span><span class="p">)</span><span class="n">lastIMP</span><span class="p">;</span>
        <span class="n">f</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">sel</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">free</span><span class="p">(</span><span class="n">methodList</span><span class="p">)</span><span class="p">;</span>   
<span class="p">}</span>

<span class="c1">// 分别调用sayHi 和 saySonHi
</span><span class="c1"></span><span class="n">Son</span> <span class="o">*</span><span class="n">mySon1</span> <span class="o">=</span> <span class="p">[</span><span class="n">Son</span> <span class="n">new</span><span class="p">]</span><span class="p">;</span>
<span class="p">[</span><span class="n">mySon1</span> <span class="n">sayHi</span><span class="p">]</span><span class="p">;</span>
<span class="p">[</span><span class="n">mySon1</span> <span class="n">saySonHi</span><span class="p">]</span><span class="p">;</span>

</code></pre></td></tr></table>
</div>
</div><h2 id="category-1">category和关联对象</h2>
<p><code>category</code>是不支持向类添加<code>实例变量</code>的。这在源码中也可以看出，<code>cateogry</code>仅支持<code>实例方法</code>、<code>类方法</code>、<code>协议</code>、和<code>属性</code>（注意，属性并没有实例变量）。
但是，runtime也给我提供了一个折中的方式，虽然不能够向类添加实例变量，但是runtime为我们提供了方法，可以向类的实例对象添加<code>关联对象</code>。
所谓<code>关联对象</code>，就是为目标对象添加一个<code>关联的对象</code>，并能够通过<code>key</code>来查找到这个<code>关联对象</code>。
这种<code>关联</code>是<code>对象</code>和<code>对象级别的</code>，而不是类层次上的。当你为一个<code>实例</code>添加一个<code>关联对象</code>后，如果你再创建另一个<code>实例</code>，这个新建的<code>实例</code>是没有<code>关联对象</code>的。
我们可以通过重写set/get方法的形式，来自动为我们的实例添加关联对象。</p>
<h2 id="heading-1">分类中都可以添加哪些内容</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="mf">6.1</span> <span class="err">实</span><span class="err">例</span><span class="err">方</span><span class="err">法</span>
<span class="mf">6.2</span> <span class="err">类</span><span class="err">方</span><span class="err">法</span>
<span class="mf">6.3</span> <span class="err">协</span><span class="err">议</span>
<span class="mf">6.4</span> <span class="err">属</span><span class="err">性</span><span class="p">(</span><span class="err">只</span><span class="err">是</span><span class="err">声</span><span class="err">明</span><span class="err">了</span><span class="n">get方法和set方法</span><span class="err">，</span><span class="err">并</span><span class="err">没</span><span class="err">有</span><span class="err">在</span><span class="err">分</span><span class="err">类</span><span class="err">中</span><span class="err">添</span><span class="err">加</span><span class="err">了</span><span class="err">实</span><span class="err">例</span><span class="err">变</span><span class="err">量</span><span class="p">)</span>
<span class="mf">6.5</span> <span class="err">分</span><span class="err">类</span><span class="err">添</span><span class="err">加</span><span class="err">实</span><span class="err">例</span><span class="err">变</span><span class="err">量</span><span class="err">，</span><span class="err">是</span><span class="err">通</span><span class="err">过</span><span class="err">关</span><span class="err">联</span><span class="err">对</span><span class="err">象</span><span class="err">实</span><span class="err">现</span><span class="err">的</span><span class="p">(</span><span class="err">后</span><span class="err">面</span><span class="err">有</span><span class="err">例</span><span class="err">子</span><span class="p">)</span>

<span class="mf">1.</span><span class="err">给</span><span class="err">已</span><span class="err">经</span><span class="err">存</span><span class="err">在</span><span class="err">的</span><span class="err">类</span><span class="err">添</span><span class="err">加</span><span class="err">方</span><span class="err">法</span><span class="p">(</span><span class="err">常</span><span class="err">用</span><span class="err">，</span><span class="err">方</span><span class="err">便</span><span class="err">给</span><span class="err">系</span><span class="err">统</span><span class="err">类</span><span class="err">添</span><span class="err">加</span><span class="err">方</span><span class="err">法</span><span class="p">)</span><span class="o">-</span><span class="o">-</span><span class="err">方</span><span class="err">法</span><span class="err">添</span><span class="err">加</span>
<span class="mf">2.</span><span class="err">把</span><span class="err">类</span><span class="err">的</span><span class="err">实</span><span class="err">现</span><span class="err">分</span><span class="err">开</span><span class="err">在</span><span class="err">几</span><span class="err">个</span><span class="err">不</span><span class="err">同</span><span class="err">文</span><span class="err">件</span><span class="err">中</span><span class="err">（</span><span class="err">大</span><span class="err">文</span><span class="err">件</span><span class="err">的</span><span class="err">拆</span><span class="err">分</span><span class="err">）</span><span class="o">-</span><span class="o">-</span><span class="err">大</span><span class="err">类</span><span class="err">拆</span><span class="err">分</span>
  <span class="mf">2.1</span><span class="p">.</span><span class="err">减</span><span class="err">少</span><span class="err">单</span><span class="err">个</span><span class="err">文</span><span class="err">件</span><span class="err">的</span><span class="err">体</span><span class="err">积</span><span class="o">-</span><span class="o">-</span><span class="err">文</span><span class="err">件</span><span class="err">拆</span><span class="err">分</span>
  <span class="mf">2.1</span><span class="p">.</span><span class="err">把</span><span class="err">不</span><span class="err">同</span><span class="err">功</span><span class="err">能</span><span class="err">组</span><span class="err">织</span><span class="err">到</span><span class="err">不</span><span class="err">同</span><span class="err">的</span><span class="n">category里</span><span class="o">-</span><span class="o">-</span><span class="err">功</span><span class="err">能</span><span class="err">划</span><span class="err">分</span>
  <span class="mf">2.2</span><span class="p">.</span><span class="err">多</span><span class="err">个</span><span class="err">开</span><span class="err">发</span><span class="err">者</span><span class="err">共</span><span class="err">同</span><span class="err">完</span><span class="err">成</span><span class="err">一</span><span class="err">个</span><span class="err">类</span><span class="o">-</span><span class="o">-</span><span class="err">多</span><span class="err">人</span><span class="err">开</span><span class="err">发</span>
  <span class="mf">2.3</span><span class="p">.</span><span class="err">按</span><span class="err">照</span><span class="err">需</span><span class="err">求</span><span class="err">加</span><span class="err">载</span><span class="err">想</span><span class="err">要</span><span class="err">的</span><span class="n">category</span><span class="o">-</span><span class="o">-</span><span class="err">按</span><span class="err">需</span><span class="err">加</span><span class="err">载</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="heading-2">分类的作用</h2>
<ul>
<li>将类的实现分散到多个不同文件或多个不同框架中(这时一般将分类写到原类的.h中，对原类分门别类)。</li>
<li>创建对私有方法的前向引用。(类.h中未声明，但存在于.m中的私有方法，通过在分类.h中声明一下。不用再分类.m中实现，在使用类中同时导入原类.h和分类.h就可以调用私有方法了)</li>
<li>向对象添加非正式协议<code>(扩展)</code>。(尖括号是正式协议，圆括号的类别是非正式协议，非正式协议的方法可以不实现）</li>
</ul>
<h5 id="1-1">分类妙用1：给原类增加新的方法接口和实现</h5>
<p>在不知道某个原类.m的具体实现时(如系统类or封装成.a的类，都只暴露原类.h给我们使用，看不到原类.m实现代码)， 在这种情况下，我们仍然可以通过 分类来给原类添加新的方法，具体做法是：在分类.h中声明方法接口，在分类.m中写方法实现代码，在需要使用的地方，导入分类.h，然后就可以调用新增的方法，而不会编译报错！</p>
<h5 id="2-1">分类妙用2：重写原类方法</h5>
<p>如果创建分类仅仅是为了重写原类中的方法，那么该分类可以不需要.h文件。并且也不需要在任何地方导入分类.h，只需要将分类.m拖入项目中,编译器在编译链接时就会覆盖原类的方法实现！
而且可以将多个分类.m防止在一个统一的.m文件中.</p>
<h5 id="3-1">分类妙用3：</h5>
<p>将某个类的私有方法变为公开方法，此种用法必须同时具备分类.h和分类.m，并且在需要用的地方导入分类.h
Cocoa没有任何真正的私有方法。只要知道对象支持的某个方法的名称，即使该对象所在的类的接口中没有该方法的声明，你也可以调用该方法。不过这么做编译器会报错，但是只要新建一个该类的类别，在类别.h文件中写上原始类该方法的声明，类别.m文件中什么也不写，就可以正常调用私有方法了。这就是传说中的<code>私有方法前向引用</code>。 所以说cocoa没有真正的私有方法。</p>
<h2 id="load--initialize">load 和 initialize</h2>
<p>load方法会在程序启动就会调用，当装载类信息的时候就会调用。
调用顺序看一下源代码。
<img src="./1543721784262.png" alt="Alt text">
<img src="./1543722482495.png" alt="Alt text">
<img src="./1543723576900.png" alt="Alt text">
可以看到分类中也是通过直接拿到load方法的地址进行调用。因此正如我们之前试验的一样，分类中重写load方法，并不会优先调用分类的load方法，而不调用本类中的load方法了</p>
<p>为Preson、Student 、Student+Test 添加initialize方法。
我们知道当类第一次接收到消息时，就会调用initialize，相当于第一次使用类的时候就会调用initialize方法。调用子类的initialize之前，会先保证调用父类的initialize方法。如果之前已经调用过initialize，就不会再调用initialize方法了。当分类重写initialize方法时会先调用分类的方法。但是load方法并不会被覆盖，首先我们来看一下initialize的源码
<img src="./1543724212483.png" alt="Alt text">
上图中说明，initialize是通过消息发送机制调用的，消息发送机制通过isa指针找到对应的方法与实现，因此先找到分类方法中的实现，会优先调用分类方法中的实现。</p>
<h2 id="9">9.思考</h2>
<p>1.Category的实现原理，以及Category为什么只能加方法不能加属性。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">分类的实现原理是将category中的方法，属性，协议数据放在category_t 结构体中，然后将结构体内的方法列表拷贝到类对象的方法列表中。
Category可以添加属性，但是并不会自动生成成员变量及set/get方法。因为category_t 结构体中并不存在成员变量。通过之前对对象的分析我们知道成员变量是存放在实例对象中的，并且编译的那一刻就已经决定好了。而分类是在运行时才去加载的。那么我们就无法再程序运行时将分类的成员变量中添加到实例对象的结构体中。因此分类中不可以添加成员变量。
</code></pre></td></tr></table>
</div>
</div><p><code>2.Category中有load方法吗？load方法是什么时候调用的？load 方法能继承吗？</code></p>
<p><code>+load方法要点</code>
+load 方法是当类或分类被添加到 Objective-C runtime 时被调用的，实现这个方法可以让我们在类加载的时候执行一些类相关的行为。子类的 +load 方法会在它的所有父类的 +load 方法之后执行，而分类的 +load 方法会在它的主类的 +load 方法之后执行。但是不同的类之间的 +load 方法的调用顺序是不确定的。</p>
<ul>
<li>一个类的 +load 方法会在它所有的父类的 +load 方法后调用。</li>
<li>一个分类的 +load 方法会在类本身的 +load 方法之后调用。</li>
<li>+load 方法不遵循继承规则， 如果某个类本身没有实现 +load 方法，不管其父类有无实现 +load 方法，系统都不会调用。</li>
<li>+load 方法务必实现得精简些，尽量减少其所需要执行的操作，整个程序可能因为 +load 方法而堵塞。</li>
<li>+load 方法真正的用途是在调试程序。</li>
<li>当有多个类别(Category)都实现了load方法,这几个load方法都会执行,但执行顺序不确定(其执行顺序与类别在Compile Sources中出现的顺序一致)</li>
<li>当然当有多个不同的类的时候,每个类load 执行顺序与其在Compile Sources出现的顺序一致</li>
</ul>
<p>load 方法的问题在于，在执行子类 load 方法之前， 必定会先执行所有父类的 load 方法， 如果还依赖了其他程序库，那么其他程序库里相关类对的 load 方法也必定会先执行。然而，根据某个给定的程序库，却无法判断出其中个各类的载入顺序。所以，在 load 方法中使用其他类是不安全的。</p>
<p>注意:
load调用时机比较早,当load调用时,其他类可能还没加载完成,运行环境不安全.
load方法是<code>线程安全</code>的，它使用了锁，我们应该避免线程阻塞在load方法.</p>
<p><code>+ load 方法特殊之处</code>
在运行时时期，循环调用所有类的 +load 方法。直接使用函数内存地址的方式 (*load_method)(cls, SEL_load); 而不是使用发送消息 objc_msgSend 的方式。</p>
<p>这个就会导致：类、父类和分类中的 +load 方法的实现是被区别对待的。也就是说如果子类没有实现 +load 方法，那么当它被加载时 runtime 是不会去调用父类的 +load 方法的。同理，当一个类和它的分类都实现了 +load 方法时，两个方法都会被调用。</p>
<p><code>+initialize方法要点</code>
initialize在类或者其子类的第一个方法被调用前调用。即使类文件被引用进项目,但是没有使用,initialize不会被调用。由于是系统自动调用，也不需要显式的调用父类的initialize，否则父类的initialize会被多次执行。假如这个类放到代码中，而这段代码并没有被执行，这个函数是不会被执行的。</p>
<p>1.父类的initialize方法会比子类先执行
2.当子类不实现initialize方法，会把父类的实现继承过来调用一遍。在此之前，父类的方法会被优先调用一次
3.当有多个Category都实现了initialize方法,会覆盖宿主类中的方法,只执行一个(会执行Compile Sources 列表中最后一个Category 的initialize方法)</p>
<p>注意:
在initialize方法收到调用时,运行环境基本健全。
initialize内部也使用了锁，所以是<code>线程安全</code>的。但同时要避免阻塞线程，不要再使用锁</p>
<p><code>3.load、initialize的区别，以及它们在category重写的时候的调用的次序。</code></p>
<p>+load 和 +initialize 方法实现的细节，明白了它们的调用机制和各自的特点。下面我们绘制一张表格，以更加直观的方式来巩固我们对它们的理解：</p>
<table>
<thead>
<tr>
<th align="left">说明</th>
<th align="right"><code>+load</code></th>
<th align="center"><code>+initialize</code></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">调用时机</td>
<td align="right">被添加到 runtime 时</td>
<td align="center">收到第一条消息前，可能永远不调用</td>
</tr>
<tr>
<td align="left">调用顺序</td>
<td align="right">父类-&gt;子类-&gt;分类</td>
<td align="center">父类-&gt;子类</td>
</tr>
<tr>
<td align="left">调用次数</td>
<td align="right">1次</td>
<td align="center">多次</td>
</tr>
<tr>
<td align="left">是否需要显式调用父类实现</td>
<td align="right">否</td>
<td align="center">否</td>
</tr>
<tr>
<td align="left">是否沿用父类的实现</td>
<td align="right">否</td>
<td align="center">是</td>
</tr>
<tr>
<td align="left">分类中的实现</td>
<td align="right">类和分类都执行</td>
<td align="center">执行多个分类中最后一个分类的实现</td>
</tr>
</tbody>
</table>
<h3 id="10">10.虽然不能在分类（类别）中定义成员变量，但是有办法也可以让它支持添加成员变量</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objectivec" data-lang="objectivec">    <span class="err">一</span><span class="err">种</span><span class="err">常</span><span class="err">见</span><span class="err">的</span><span class="err">办</span><span class="err">法</span><span class="err">是</span><span class="err">通</span><span class="err">过</span><span class="n">runtime</span><span class="p">.</span><span class="n">h中objc_getAssociatedObject</span> <span class="o">/</span> <span class="n">objc_setAssociatedObject来访问和生成关联对象</span><span class="err">。</span><span class="err">通</span><span class="err">过</span><span class="err">这</span><span class="err">种</span><span class="err">方</span><span class="err">法</span><span class="err">来</span><span class="err">模</span><span class="err">拟</span><span class="err">生</span><span class="err">成</span><span class="err">变</span><span class="err">量</span><span class="err">。</span>
</code></pre></td></tr></table>
</div>
</div><p>“NSObject+SpecialName.h”文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="n">interface</span> <span class="nf">NSObject</span> <span class="p">(</span><span class="n">SpecialName</span><span class="p">)</span>
<span class="n">property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">specialName</span><span class="p">;</span>
<span class="n">end</span>
</code></pre></td></tr></table>
</div>
</div><p>“NSObject+SpecialName.m”文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="cp">#</span><span class="cp">import &#34;NSObject+Extension.h&#34;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">import &lt;objc</span><span class="cp">/</span><span class="cp">runtime.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">SpecialNameKey</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">SpecialNameKey</span><span class="p">;</span>    
<span class="k">@implementation</span> <span class="nc">NSObject</span> <span class="nl">(SpecialName)</span>
<span class="k">@dynamic</span> <span class="n">specialName</span><span class="p">;</span>

<span class="p">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">specialName</span> <span class="p">{</span>
    <span class="c1">//如果属性值是非id类型，可以通过属性值先构造OC的id对象，再通过对象获取非id类型属性
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">objc_getAssociatedObject</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">SpecialNameKey</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setSpecialName:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">specialName</span><span class="p">{</span>
    <span class="c1">//如果属性值是非id类型，可以通过属性值先构造OC的id对象，再通过对象获取非id类型属性
</span><span class="c1"></span>    <span class="n">objc_setAssociatedObject</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">SpecialNameKey</span><span class="p">,</span> <span class="n">specialName</span><span class="p">,</span> <span class="n">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span><span class="p">)</span><span class="p">;</span> 
<span class="p">}</span> 
<span class="k">@end</span>
</code></pre></td></tr></table>
</div>
</div>
  </div>
</article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:kidzss@163.com" class="iconfont icon-email" title="email"></a>
      <a href="http://localhost:1313" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="http://localhost:1313" class="iconfont icon-twitter" title="twitter"></a>
      <a href="http://localhost:1313" class="iconfont icon-facebook" title="facebook"></a>
      <a href="http://localhost:1313" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="http://localhost:1313" class="iconfont icon-google" title="google"></a>
      <a href="http://localhost:1313" class="iconfont icon-github" title="github"></a>
      <a href="http://localhost:1313" class="iconfont icon-weibo" title="weibo"></a>
      <a href="http://localhost:1313" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="http://localhost:1313" class="iconfont icon-douban" title="douban"></a>
      <a href="http://localhost:1313" class="iconfont icon-pocket" title="pocket"></a>
      <a href="http://localhost:1313" class="iconfont icon-tumblr" title="tumblr"></a>
      <a href="http://localhost:1313" class="iconfont icon-instagram" title="instagram"></a>
      <a href="http://localhost:1313" class="iconfont icon-gitlab" title="gitlab"></a>
      <a href="http://localhost:1313" class="iconfont icon-bilibili" title="bilibili"></a>
  <a href="https://kidzss.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> 本站总访问量 <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次 </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> 本站总访客数 <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 人 </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2017 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">kidzss</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>








</body>
</html>
